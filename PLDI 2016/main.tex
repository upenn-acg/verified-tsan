\documentclass[preprint, 10pt]{sigplanconf}

\usepackage{uri}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage{graphicx}
\usepackage{cases}
\usepackage{xcolor}
\usepackage{xspace}

\newcommand{\TODO}[1]{\textbf{\textcolor{red}{[ TODO: #1]}}}
\newcommand{\ignore}[1]{}
\newcommand{\con}[1]{\ensuremath{\mathsf{consistent}(#1)}}
\newcommand{\seqcon}[1]{\ensuremath{\mathsf{seq\_con}(#1)}}
\newcommand{\mread}[2]{\ensuremath{\mathsf{read}(#1, #2)}}
\newcommand{\mwrite}[2]{\ensuremath{\mathsf{write}(#1, #2)}}
\newcommand{\malloc}[2]{\ensuremath{\mathsf{alloc}(#1, #2)}}
\newcommand{\mfree}[1]{\ensuremath{\mathsf{free}(#1)}}
%\newcommand{\cccando}[2]{\ensuremath{\mathsf{can\_do_{CC}}(#1, #2)}}
\newcommand{\hb}[0]{<_{\mathrm{hb}}}
\newcommand{\po}[0]{<_{\mathrm{po}}}
\newcommand{\sw}[0]{<_{\mathrm{sw}}}
\newcommand{\word}[0]{<_{\mathrm{w}}}

\newcommand{\assign}[2]{#1\ \texttt{:=}\ #2}
\newcommand{\load}[2]{#1\ \texttt{:= load}\ #2}
\newcommand{\store}[2]{\texttt{store}\ #2\ #1}
\newcommand{\lock}[1]{\texttt{lock}\ #1}
\newcommand{\unlock}[1]{\texttt{unlock}\ #1}
\newcommand{\spawn}[2]{\texttt{spawn}\ #1\ #2}
\newcommand{\wait}[1]{\texttt{wait}\ #1}
\newcommand{\assert}[2]{\texttt{assert(}#1\ \texttt{<=}\ #2\texttt{)}}

%from StackExchange, a better xrightarrow^*
\newcommand{\tto}[1]{\mathrel{
  \vphantom{\xrightarrow{#1}}
  \smash{\xrightarrow{#1}}
  \vphantom{\to}^{*}}
}

\hyphenation{Comp-Cert}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{principle}{Principle}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

%\conferenceinfo{PLDI '16}{June 13--17, 2016, Santa Barbara, California, United States} 
%\copyrightyear{2016}
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
%\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Verifying Dynamic Race Detection}
\ignore{\authorinfo{William Mansky \and Yuanfeng Peng \and Steve Zdancewic \and Joseph Devietti}
           {University of Pennsylvania}
           {wmansky@seas.upenn.edu, yuanfeng@cis.upenn.edu, stevez@cis.upenn.edu, devietti@cis.upenn.edu}}
\authorinfo{}{}{}
\maketitle

\begin{abstract}
Writing race-free concurrent code is notoriously difficult, and races can result in bugs that are difficult to isolate and reproduce. Dynamic race detection is often used to catch races that cannot (easily) be detected statically. One approach to dynamic race detection is to instrument the potentially racy code with operations that store and compare metadata, where the metadata implements some known race detection algorithm (e.g. vector clock race detection). In this paper, we lay out an instrumentation pass for race detection in a simple language, and present a mechanized formal proof of its correctness: all races in a program will be caught by the instrumentation, and all races detected by the instrumentation are possible in the original program.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\keywords
%dynamic race detection, interactive theorem proving

\section{Introduction}

Multicore processors have steadily invaded a broad swathe of the computing ecosystem in everything from datacenters to smart watches. Writing multithreaded code for such platforms can bring good performance but also a host of programmability challenges. One of the key challenges is dealing with data races, as the presence of a data race introduces non-sequentially-consistent \cite{manson_java_2005} and in some cases undefined \cite{boehm_foundations_2008} behavior into programs, making program semantics very difficult to understand. Races are not detected by default in current language runtimes, though there are many systems that provide sound and complete data race detection via dynamic analysis \cite{djit+,fasttrack,slimstate,slimfast} to help programmers detect and remove data races from their programs. 

While these analyses have been proven correct, such proofs have two main shortcomings: they are proofs of the algorithms, instead of the implementations, and they are paper proofs instead of machine-checked proofs. Because of these shortcomings, it is possible that a race detector does not faithfully implement its algorithm, or that the algorithm itself is not fully correct. 

In this paper, we seek to rectify these concerns and place dynamic race detection on a provably-correct foundation for the first time. We have begun by formalizing the proof of the classic vector clock race detection algorithm \cite{fidge,friedmann_mattern} using the Coq interactive theorem prover \cite{coq}. Having established the correctness of this base algorithm, we extend our work along two dimensions. 

\TODO{figure showing these two dimensions?}

We first explore the \textbf{algorithmic dimension}, by formally establishing the correctness of the FastTrack algorithm \cite{fasttrack}. FastTrack includes several significant optimizations over the base vector clock algorithm. We find that the correctness of FastTrack can be demonstrated by proving its equivalence to the vector clock algorithm, which is a more straightforward process than demonstrating correctness in isolation, and likely lends itself to formalizing additional algorithms with reduced effort. Our verification efforts have revealed a small issue in the paper proof from \cite{fasttrack} that, while fixable, illustrates the potential dangers that stem from best-effort proofs. We have repaired this issue in our proof of FastTrack, establishing that the algorithm is correct.

We next explore the \textbf{implementation dimension}, by formally establishing in Coq the correctness of an implementation of vector clock race detection on a simple imperative language with threads. Given a program written in our language, our race detector adds instrumentation, written in the same language, to the program to perform vector clock race detection. We demonstrate that this instrumentation correctly implements the vector clock algorithm, again leveraging our previous verification effort. We also prove that our implementation preserves the program's semantics in the absence of races. While constructing our implementation, we consulted the existing implementation of FastTrack for guidance and our verification process brought to light an example of extraneous work performed by the current FastTrack implementation. This issue is unlikely to have come to light otherwise, but when proving our implementation equivalent to the abstract algorithm such discrepancies were quickly revealed. This again demonstrates the value of formal verification over best-effort implementation, ensuring that an implementation does no less, and no more, than is necessary for correctness.

To the best of our knowledge, ours is the first work to adopt formal verification for either race detection algorithms \emph{or} their implementations. Moreover, we believe our general approach may be useful as a template for verifying a broad range of dynamic analyses, especially in the challenging domain of analyses for parallel programs. Verification is critical to help ensure that debugging tools are themselves free from bugs.

This paper makes the following contributions:

\begin{itemize}
\item We present a method for verifying a dynamic data race detector from the algorithmic level through to its implementation
\item We give the first verified proofs of correctness of the vector clock and FastTrack data race detection algorithms
\item We give the first verified implementation of vector clock race detection on a simple, imperative multithreaded language
\item We uncover issues in the paper proof of correctness for FastTrack and in its current implementation, that are unlikely to have been revealed without our verification efforts. We repair these issues in our own proofs and implementation.
\end{itemize}

The remainder of this paper is organized as follows \TODO{...}

\section{Proof Strategy}
Our approach involves two levels: verifying the high-level algorithm, and proving that an instrumentation pass implements the algorithm.

\section{Race Detection Algorithms}
\subsection{Vector Clock Race Detection}
definition

verification

\subsection{FastTrack}
definition

verification

And we found a bug.

\section{Instrumenting a Simple Language}
\subsection{The Language}
We define a simple multithreaded language that is just complicated enough to have races and implement race detection instrumentation. The instructions of the language are defined as follows, where $n$ is a natural number, $a$ is a local variable, $e, e1, e2$ are expressions, $p$ is a pointer, $l$ is a lock, $t$ is a thread id, and $i_j$ are instructions:
\begin{align*}\mathit{expr} ::= n~|~a~|~e_1 + e_2~|~\mathtt{max}(e_1, e_2)\end{align*}
\begin{align*}\mathit{instr} ::=\ &\assign{a}{e}~|~\load{a}{p}~|~\store{p}{e}~|~\lock{l}~\\|~&\unlock{l}~|~\spawn{t}{i_1, ..., i_n}~|~\wait{t}~\\|~&\assert{e_1}{e_2}\end{align*}
A \emph{program} is simply a list of instructions. The dynamic state of a program contains a collection of threads, where a thread is a pair $(t, \mathit{li})$ of a tid and a list of instructions, and a family of local environments $G_t$, one for each thread, assigning values to local variables. We give semantics to the language via a transition system of the form $(P, G) \xrightarrow{o, c} (P', G')$, where $P, P'$ are collections of threads, $G, G'$ are environments, $o$ is a race detection operation (if one is produced by the step), and $c$ is a concurrent memory operation (likewise). We define a function $\mathsf{eval}$ that takes a local environment and an expression and yields the value of the expression. The semantics of the language are shown in Figure~\ref{semantics}.

\begin{figure}[htb]
$$\inference[assign]{}{(e_1\ ...\ (t, \assign{a}{e}\ \mathit{li})\ ...\ e_k, G) \rightarrow (e_1\ ...\ (t, \mathit{li})\ ...\ e_2, G[G_t[a \mapsto \mathsf{eval}(G_t, e)]])}$$

\caption{Semantics of the simple language}
\label{semantics}
\end{figure}


\subsection{Instrumentation}

\subsection{Necessary Synchronization}
Completely unsynchronized instrumentation cannot be sound and complete. (example) At the same time, adding too much synchronization could significantly hurt performance.

\section{Verifying Instrumentation}
We verify the correctness of the instrumentation by showing that instrumentation records the same information and performs the same checks as the algorithm would perform on any program.

lemmas relating each instrumentation segment to vector clock operations

simulation relation and clear statements of two directions

wait-wait races

\section{Related Work}

\TODO{discuss verified instrumentation like SoftBound, RockSalt SFI? I don't think either of these support multithreading.}

There is a rich history of systems that provide dynamic data race detection, dating back to the original proposals of the vector clock algorithm \cite{friedmann,mattern,lamportvc}. Subsequent systems have implemented vector clocks, with various optimizations, using dynamic analysis to provide race detection for C/C++ \cite{pozniansky_efficient_2003,serebryany_threadsanitizer:_2009} and Java \cite{christiaens_trade:_2001,elmas_goldilocks:_2007,flanagan_fasttrack:_2009,flanagan_fasttrack:_2010,slimstate} programs. These systems have relied on paper proofs to demonstrate correctness, but these proofs have not been mechanically verified until our work. Furthermore, these paper proofs operate at a high level of abstraction, using an operational semantics that elides important details such as the synchronization used within the race detector itself. Thus, the implementations of these algorithms are far removed from the algorithms themselves, leaving the door open for bugs.

Lockset-based race detection \cite{dinning_detecting_1991,savage_eraser:_1997}, an alternative to the traditional vector clock data race detection algorithm, reports false races on some common programming idioms like privatization but can also detect with a single execution some races that would require multiple executions to detect with vector clocks. Other work has generalized vector clock race detection to detect more races from a single execution \cite{smaragdakis_sound_2012,sen_detecting_2005,chen_parametric_2007} at the cost of decreased performance.

Several forms of sampling-based dynamic race detection have been proposed. Such schemes trade soundness \cite{greathouse_demand-driven_2011,bond_pacer:_2010,marino_literace:_2009,erickson_effective_2010,effinger-dean_ifrit:_2012} for reduced performance overheads.

There have been several proposals for static race detection \cite{engler_racerx:_2003,naik_effective_2006} or static analysis \cite{flanagan_redcard:_2013,joserenau} to prune race detection instrumentation and metadata at compile time, which can serve as a complement to our dynamic approach. Others have proposed type systems \cite{abadi_types_2006,bocchino_type_2009,rust} and implicitly-parallel languages \cite{rinard_design_1998,guy_blelloch_nesl:_1992} that eliminate data races by construction, though these systems sacrifice expressiveness to obtain race-freedom guarantees.

Several systems exist for detecting data races in structured parallel programs such as fork-join programs \cite{john_mellor-crummey_--fly_1991,feng_efficient_1997,mai_zheng_grace:_2011,michael_boyer_automated_2008}, async-finish programs \cite{raman_scalable_2012} or programs with asynchronous callbacks \cite{petrov_race_2012,raychev_effective_2013,hsiao_race_2014,vechev_oopsla_2015}. Structured parallelism admits more time- and space-efficient data race detection than the general multithreaded programs we support. None of these prior algorithms or implementations have been formally verified, however, so they represent a potentially fruitful area for future work.


\section{Conclusions and Future Work}

We have presented the first verified proofs of correctness of the vector clock and FastTrack race detection algorithms, and a verified implementation of vector clock race detection for a simple multithreaded language. Our verification efforts have revealed an issue in the original paper proof of correctness for FastTrack, and an instance of unnecessary computation in the FastTrack implementation. Our work places dynamic data race detection on a formally-verified foundation for the first time.

There are many natural avenues for extending our work: to verify new algorithms for race detection or other dynamic analyses, new implementations, and implementations in richer languages such as LLVM bytecode or C. The amount of effort expended to achieve our verified implementation suggests that richer verified abstractions are necessary to scale such efforts further and bring the benefits of verified dynamic analysis to a wider audience.

\bibliographystyle{abbrvnat}
\bibliography{sources}

% !! The bibliography should be embedded for final submission.

\end{document}
